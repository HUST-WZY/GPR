# 工作汇报

## 1. 数据集描述

原始数据集为机器人手臂数据集[The SARCOS data](http://www.gaussianprocess.org/gpml/data/)，输入为21维：7个关节位置、7个关节速度、7个关节加速度，输出为7维：7个关节扭矩，数据集的数据总量为**4万**级的。

但是21输入7输出的万级数据集，对我们的内存不友好，所以使用`PCA`进行降维，将输入从21维降到了4维，输出从7维降到了2维，并且都保留了至少 90% 的信息——这也反应了原数据集中确实存在较多冗余的信息。

## 2. 方法描述

### 2.1 传统方法

直接建立`GPR`模型，即建立一个4输入2输出的`GPR`模型，然后训练、测试。

### 2.2 改进方法

我们有公式：
$$
\begin{equation}
y(t) = y(t - 1) + g(t)\cdot u(t)         \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (1)
\end{equation}
$$
其中 $$y(t)$$ 为 $$t$$ 时刻的模型输出，$$u(t)$$ 为 $$t$$ 时刻的模型输入，$$g(t)$$ 为 $$t$$ 时刻，整个系统在时间轴上传递的信息，不妨将其称为 **足迹**。并且注意，如果 $$u(t)$$ 是 $$m$$ 维，$$y(t)$$ 是 $$n$$ 维，那么 **足迹** 是 $$n \times m$$ 维的矩阵。

假设训练数据集涵盖的时间间隔为 $$\left [ 0, t_{1} \right ]$$ ，测试数据集涵盖的时间间隔为 $$\left [ t_{1}, t_{2} \right ]$$ ，我们的改进方法分三步走：

1. **初始化**：根据训练数据集及上面的公式(1)，计算 $$\left [ 1, t_{1} \right ]$$ 每一个时刻的 **过去的足迹**；
2. **训练**：以 $$\left [ 1, t_{1} \right ]$$ 为`GPR`的输入，对应的 **过去的足迹** 为`GPR` 的输出，训练`GPR`模型，即时间序列的`GPR`模型；
3. **预测**：将 $$\left [ t_{1}, t_{2} \right ]$$ 输入训练好的 `GPR`模型，得到预测的 **未来的足迹**；将 **未来的足迹** 及 $$\left [ t_{1}, t_{2} \right ]$$ 时刻的  $$y(t)$$ 和 $$u(t)$$ 带入公式(1)，即可求得预测的 $$\left [ t_{1}, t_{2} \right ]$$ 时刻模型的输出。

## 3. 实验结果

在第2节的方法描述中，我们只是提了一下"`GPR`模型"，但具体用什么"`GPR`模型"，是没有明确的。

由于数据集是4输入2输出，所以 **足迹** 是 $$2 \times 4$$ 维的矩阵，也就是说，我们要训练的"`GPR`模型"为 1输入 8输出。

结合本实验的场景及对"`GPR`模型"的了解、经验，选择了如下几个具体的"`GPR`模型"进行对比实验。实验中均使用数据集的前 60% 作为训练数据，后 40% 作为测试数据。所有实验结果均可复现。

### 3.1 多输出的 GPR

[论文](https://papers.nips.cc/paper/2007/file/66368270ffd51418ec58bd793f2d9b1b-Paper.pdf)

[代码](https://github.com/HUST-WZY/GPR/tree/main/sarcos/MOGPR)

精确的推断，数据过多，需要分批训练。`SE`核函数。

| 方法 |        MAE         |        MSE         |        RMSE        |
| :--: | :----------------: | :----------------: | :----------------: |
| 传统 |  [0.3847，0.4559]  |  [0.2564，0.4035]  |  [0.5063，0.6352]  |
| 改进 | [0.09760，0.13751] | [0.02395，0.05181] | [0.15477，0.22762] |

### 3.2 GPR 神经网络

[论文](https://arxiv.org/abs/1705.08933)

[代码](https://github.com/HUST-WZY/GPR/tree/main/sarcos/NN2)

`SE`核函数。

将 GPR 搭建成神经网络。这个方法目前遇到的问题：

* 无法使用 GPU，有未查明原因的报错。这导致训练缓慢。
* 神经网络可以有多种结构（不同的层、每层不同的节点数等），还没有进一步去尝试各种结构的效果。

| 方法 |        MAE         |        MSE         |        RMSE        |
| :--: | :----------------: | :----------------: | :----------------: |
| 传统 |  [0.6359，0.6804]  |  [0.6145，0.8330]  |  [0.7839，0.9127]  |
| 改进 | [0.09836，0.13736] | [0.02416，0.05184] | [0.15543，0.22767] |

### 3.3 每个维度单独建模

[论文：KISS-GP](http://proceedings.mlr.press/v37/wilson15.pdf)、[论文：SM核](https://arxiv.org/pdf/1302.4245.pdf)

[代码](https://github.com/HUST-WZY/GPR/tree/main/sarcos/SM_KISS_GP_per)

这里首先是考虑到，我们要训练一个1输入 8输出的 `GPR`，这个从直觉上来说，难度有点大。

> 由于大多数机器学习方法没有扎实的理论依据，但大多数机器学习方法又都是仿照人学习的过程去做的。所以在评估机器学习方法时，个人感觉，想想人是怎么学习的是有帮助的。

然后，我们是要学习的 **足迹** 是时间序列嘛，那就肯定是外推。`GPR`最为人称道的外推方法就是使用`SM`核函数，但上面的方法中，不是单独使用`SM`核函数，有可能会削弱其外推优势。

所以，这里对每个输入维度单独建模，即建立8个1输入1输出的`GPR`，并使用`SM`核函数。

对于每个输出维度的`GPR`，使用`SM + KISS-GP`建模。得益于`KISS-GP`的可扩展性，不需要分批训练。

| 方法 |        MAE         |        MSE         |        RMSE        |
| :--: | :----------------: | :----------------: | :----------------: |
| 传统 |      惨不忍睹      |      惨不忍睹      |      惨不忍睹      |
| 改进 | [0.09808，0.13821] | [0.02434，0.05281] | [0.15602，0.22981] |

